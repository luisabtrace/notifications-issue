import { createReducer } from "@reduxjs/toolkit";
import { NotificationState } from "./types";
import { enqueueNotification, removeNotification } from "./notificationActions";
import { createDraft } from "immer";

const initialValue: NotificationState = {
  notifications: [],
};

export const notificationReducer = createReducer(initialValue, (builder) => {
  builder
    .addCase(enqueueNotification, (state, action) => {
      const { payload } = action;

      if (payload.options.onePerKey) {
        const existing = state.notifications.find((ntf) => ntf.options.key === payload.options.key);

        if (existing) {
          return;
        }
      }

      // Delete all notifications for the same key EXCEPT the first, because
      // presumably that's the one currently being displayed.
      // This is to avoid spamming the user with too many simultaneous
      // notifications which would just be displayed for a few milliseconds
      // before being replaced by another notification with the same key
      const [notifications] = state.notifications.reduce(
        ([acc, foundKey], notification) => {
          if (foundKey && notification.options.key === action.payload.options.key) {
            return [acc, foundKey];
          }
          return [[...acc, notification], foundKey || notification.options.key === action.payload.options.key];
        },
        [[] as typeof state.notifications, false]
      );

      state.notifications = [
        ...notifications,
        createDraft({
          message: action.payload.message,
          options: action.payload.options,
        }),
      ];
    })
    .addCase(removeNotification, (state, action) => {
      let notifications = state.notifications;
      if (typeof action.payload.key === "number") {
        // If the key is a number, this must be a notification originally
        // created without a key (and the number was generated by notistack).
        // In this case, we want to remove the first notification from the
        // store with no key and the same message, because that was the
        // notification that was displayed.
        const index = state.notifications.findIndex(
          ({ options, message }) => typeof options.key === "undefined" && message === action.payload.message
        );

        if (index > -1) {
          notifications = [...state.notifications];
          notifications.splice(index, 1);
        }
      } else if (typeof action.payload.key === "string") {
        // If the key is a string, the notification was created with a key and
        // we want to remove the first notification with the same key and message,
        // because presumably that was the one that was displayed.
        // Note that multiple notifications with the same key and message are
        // totally possible (but only one will be displayed at a time)
        const index = state.notifications.findIndex(
          ({ options, message }) => options.key === action.payload.key && message === action.payload.message
        );

        if (index > -1) {
          notifications = [...state.notifications];
          notifications.splice(index, 1);
        }
      }

      state.notifications = notifications;
    });
});
